TRABAJO PRACTICO 4

"CLASE 09/10"

"Realizar un método que devuelva si un número es primo o no. El método se debe llamar: esPrimo y devolver verdadero o falso."
"Clase: SmallInteger - - mathematical functions"
esPrimo
| primo divisor resto | 
"self es el numero que viene como parametro" 
(self <= 1) ifTrue: [ 
	^false. 
	].  
divisor:= 2. 
primo:= true.  
" ~= es el signo distinto " 
[primo & (((self sqrt)) >= divisor)] whileTrue: [  	
	((self \\ divisor) = 0) ifTrue: [  	  
		primo:= false. 	
		]     
	ifFalse: [      	 
		divisor:= divisor + 1.   	
		].     
	].
^primo.



“Realizar un método que devuelva un arreglo de dos (2) elementos donde el elemento uno es la parte entera y el elemento 2 es la parte decimal 
Ejemplo: 23.44 dividirNumero ----> #(23 44) “
“Clase: SmallFloat64“ 
DividirNumero
| nro |  
nro:= self asString.  
nro:= nro substrings: '.'.  
nro at: 1 put: (nro at: 1) asInteger. 
nro at: 2 put: (nro at: 2) asInteger. 
^nro.



"Dado un arreglo de números encontrar, realizar un método que encuentre el mayor valor y otro método que encuentre el menor valor."
"Clase: Array"
buscoMayor  
| mayor |  
mayor:= self at: 1. "tomo el primer elemento como mayor" 
"salteo la primer iteracion" 
2 to: (self size) do: [ :i| 	 	
	((self at: i) isNumber) ifTrue: [  		
		((self at: i) > mayor) ifTrue: [  			
			mayor:= self at: i. 			
			]. 		
		].  	
		"si no es un numero, lo saltea" 	
	]. 
^mayor.


"Dado un arreglo de números encontrar, realizar un método que encuentre el menor valor. #(20 38 13 1)"
"Clase: Array"
buscoMenor  
| menor |  
menor:= self at: 1. "tomo el primer elemento como menor" 
"salteo la primer iteracion" 
2 to: (self size) do: [ :i| 	 	
	((self at: i) isNumber) ifTrue: [  		
		((self at: i) < menor) ifTrue: [  			
			menor:= self at: i. 			
			]. 		
		].  	
		"si no es un numero, lo saltea" 	
	]. 
^menor.


"CLASE 10/10"

"Cargar un arreglo con 30 elementos aleatorios, entre –1000 y 1000.
Crear una lista con los elementos que estén en un rango ingresado por el usuario. 
Imprimir la lista. 
Informar la cantidad de elementos de la lista." 
| lista arreglo menor mayor |

lista:= OrderedCollection new.
arreglo:= Array new: 30. "creo un arreglo de 30 elementos"

"cargo el arreglo"
1 to: (arreglo size) do: [ :i|
	"() atRandom , te da un elemento aleatorio en ese rango"
	arreglo at: i put: ((-1000 to: 1000) atRandom).
	].

menor:= (UIManager default request: 'Ingrese el menor valor del rango de la lista') asInteger.
"controlo que no ingrese una palabra"
[menor = nil] whileTrue: [ 
	menor:= (UIManager default request: 'Numero no valido, intente nuevamente') asInteger.
	].

mayor:= (UIManager default request: 'Ingrese el mayor valor del rango de la lista') asInteger.
"controlo que no ingrese una palabra y que este bien ingresado el rango"
[mayor = nil and: (menor > mayor)] whileTrue: [ 
	mayor:= (UIManager default request: 'Numero no valido, intente nuevamente') asInteger.
	].

"cargo la lista"
arreglo do: [:c|
	"pregunto si el elemento esta en el rango solicitado"
	((c >= menor) and: (c <= mayor)) ifTrue: [ 
		lista add: c.
		].
	].

Transcript clear.
Transcript show: (arreglo) ; cr.
Transcript show: 'El rango inferior es ', menor asString, ' y el rango superior es ', mayor asString ; cr.
Transcript show: (lista) ; cr.
Transcript show: ('La cantidad de elementos de la lista es ', (lista size) asString).




"CLASE 16/10"

"EJERCICIO 5"
"Pasar un período expresado en segundos a un período expresado en días, horas, minutos y segundos." 
"Clase: Smallinteger - mathematical functions" 

Solucion 1:
obtenerPeriodo

| segundos minutos horas dias periodo |

segundos:= self.
"convierto los segundos a dias"
"1 dia = 86400 segundos"
dias:= 0.
[segundos > 86400] whileTrue: [ 
	segundos:= segundos - 86400.
	dias:= dias + 1.
	].

"convierto los segundos a horas"
"1 hora = 3600 segundos"
horas:= 0.
[segundos > 3600] whileTrue: [ 
	segundos:= segundos - 3600.
	horas:= horas + 1.
	].

"convierto los segundos a horas"
"1 minuto = 60 segundos"
minutos:= 0.
[segundos > 60] whileTrue: [ 
	segundos:= segundos - 60.
	minutos:= minutos + 1.
	].

"formo el periodo para poder mostrar"
periodo:= (dias asString, ' dias ', horas asString, ' horas ', minutos asString, ' minutos ', segundos asString, ' segundos').
^periodo.


Solucion 2:
obtenerPeriodoo

| segundos minutos horas dias periodo |

segundos:= self.
"convierto los segundos a dias"
"1 dia = 86400 segundos"
dias:= segundos // 86400. "obtengo los dias"
segundos:= segundos \\ 86400. "obtengo los segundos para seguir operando"

"convierto los segundos a horas"
"1 hora = 3600 segundos"
horas:= segundos // 3600. "obtengo los horas"
segundos:= segundos \\ 3600. "obtengo los segundos para seguir operando"

"convierto los segundos a horas"
"1 minuto = 60 segundos"
minutos:= segundos // 60. "obtengo los horas"
segundos:= segundos \\ 60. "obtengo los segundos para seguir operando"

"formo el periodo para poder mostrar"
periodo:= (dias asString, ' dias ', horas asString, ' horas ', minutos asString, ' minutos ', segundos asString, ' segundos').
^periodo.



"EJERCICIO 6"
"Hacer un método que dada una fecha en formato DD/MM/AA, verifique si es correcta o errónea. Ej.: El 31/02/97 es una fecha errónea."
verificarFecha
| fecha meses año dia mes |
fecha:= self.

((fecha size) = 8) ifFalse: [ 
	^'Fecha ingresada es invalida'.
	].

"controlo que este bien ingresado el formato DD/MM/AA"
1 to: (fecha size) do: [ :i|
	"pregunto por la posicion de la /"
	((i = 3) or: (i = 6)) ifTrue: [ 
		"pregunta si no es la /"
		((fecha at: i) ~= $/) ifTrue: [ 	
			^'Fecha ingresada es invalida'.
			].	 
		] 
	"tiene que venir un numero"
	ifFalse: [ 
		"convierto el caracter a string y dps a numero"
		(((fecha at: i) asString asInteger) isInteger) ifFalse: [ 
			
			^'Fecha ingresada es invalida'.
			].
		].	
	].

"controlo que sea un fecha existente"

"en este caso AA todos los años son validos"
año:= (fecha copyFrom: 7 to: 8) asInteger. "saco el año"
"pregunto si no es año bisiesto"
((año \\ 4) = 0) ifTrue: [ 
	"cada posicion es un mes, con la cantidad de dias"
	meses:= #[31 29 31 30 31 30 31 31 30 31 30 31].
	]
ifFalse: [ 
	"en febrero reemplazo por 28 en vez de 29"
	meses:= #[31 28 31 30 31 30 31 31 30 31 30 31].
	].

mes:= (fecha copyFrom: 4 to: 5) asInteger. "saco el mes"
(mes > 12) ifTrue: [ 
	^'Fecha ingresada es invalida'.
	].

dia:= (fecha copyFrom: 1 to: 2) asInteger. "saco el dia"
(dia > (meses at: mes)) ifTrue: [ 
	^'Fecha ingresada es invalida'.
	].

^'Fecha ingresada es valida'.



"Hacer un método que dada una fecha en formato DD/MM/AAAA o DD-MM-AAAA, verifique si es correcta o errónea. Ej.: El 31/02/1997 es una fecha errónea."
verificarFechaa

| fecha meses año dia mes |

fecha:= self.

((fecha size) = 10) ifFalse: [ 
	^'Fecha ingresada es invalida, error de longitud'.
	].

"controlo que este bien ingresado el formato DD/MM/AAAA"
1 to: (fecha size) do: [ :i|
	
	"pregunto por la posicion de la / o -"
	((i = 3) or: (i = 6)) ifTrue: [ 
		"pregunta si no es la / o -"
		(((fecha at: i) ~= $/) and: ((fecha at: i) ~= $-)) ifTrue: [ 
			^'Fecha ingresada es invalida, error de formato'.
			].
		
		] 
	"tiene que venir un numero"
	ifFalse: [ 
		
		"convierto el caracter a string y dps a numero"
		(((fecha at: i) asString asInteger) isInteger) ifFalse: [ 
			^'Fecha ingresada es invalida, error de formato'.
			].
		].
	
	].

"controlo que sea un fecha existente"

año:= (fecha copyFrom: 7 to: 10) asInteger. "saco el año"
(año > 2024) ifTrue: [ 
	^'Fecha ingresada es invalida, error en el año'.
	].

"pregunto si no es año bisiesto"
((año \\ 4) = 0) ifTrue: [ 
	"cada posicion es un mes, con la cantidad de dias"
	meses:= #[31 29 31 30 31 30 31 31 30 31 30 31].
	]
ifFalse: [ 
	"en febrero reemplazo por 28 en vez de 29"
	meses:= #[31 28 31 30 31 30 31 31 30 31 30 31].
	].

mes:= (fecha copyFrom: 4 to: 5) asInteger. "saco el mes"
(mes > 12) ifTrue: [ 
	^'Fecha ingresada es invalida, error en el mes'.
	].

dia:= (fecha copyFrom: 1 to: 2) asInteger. "saco el dia"
(dia > (meses at: mes)) ifTrue: [ 
	^'Fecha ingresada es invalida, error en el dia'.
	].

^'Fecha ingresada es valida'.



"EJERCICIO 10"
"Construir un método ‘longitudes’ tal que, dada una lista de cadenas, devuelva una lista de pares 
ordenados que representen la ubicación de cada cadena y su longitud. Ej.: longitudes [‘este’, ‘es’, 
‘el’, ‘ejemplo’, ‘sí?’]. Devolverá: [(1,4),(2,2),(3,2),(4,7),(5,3)]       (no pidio el profe este ejercicio)"
"para probar #('este' 'es' 'el' 'ejemplo' 'si?') longitudes" 
"Clase: Array - Converting"

longitudes
| arreglo salida |

arreglo:= self.

arreglo do: [ :c| 
	(c isString) ifFalse: [
		^'Error, un elemento del arreglo no es un string'.
		].
	].

salida:= Array new: (arreglo size).
1 to: (arreglo size) do: [ :i|
	
	salida at: i put: ('(', i asString, ',', ((arreglo at: i) size) asString, ')').
	].

^salida.



"EJERCICIO 14"
"Hacer un método que dado un conjunto de palabras, permita armar otra; esta se formará con las 
iniciales de las palabras que empiezan con una consonante y con la última consonante. 
Ej.: MetodoY [‘universidad’, ‘tecnológica’, ‘nacional’]. Devolverá: ‘DTNL’"
"para probar si funciona #('universidad' 'tecnológica' 'nacional') convertirConsonante."
"Clase: Array - Converting"

convertirConsonante

| arreglo vocales salida primerLetra ultimaLetra bandera |

arreglo:= self.
vocales:= #(A E I O U).
salida:= ''.

arreglo do: [ :c|
	(c isString) ifFalse: [ 
		^'Error, el arreglo no contiene solamente palabras'.
		].
	].

1 to: (arreglo size) do: [ :i|
	
	bandera:= true. "reinicio"
	"pregunto por la primera posicion"
	primerLetra:= (arreglo at: i) at: 1.
	vocales do: [ :c|
		"convierto ambos a string, porque el elemento de vocales lo devuelve como ByteSymbol"
		((primerLetra asUppercase asString) = (c asString)) ifTrue: [
			"cuando sea vocal pongo bandera en falso" 
			bandera:= false.
			]. 
		].
	(bandera) ifTrue: [ 
		salida:= (salida, primerLetra asUppercase asString).
		].
	
	bandera:= true. "reinicio"
	"pregunto por la ultima posicion"
	ultimaLetra:= (arreglo at: i) at: ((arreglo at: i) size).
	vocales do: [ :c|
		"convierto ambos a string, porque el elemento de vocales lo devuelve como ByteSymbol"
		((ultimaLetra asUppercase asString) = (c asString)) ifTrue: [ 
			"cuando sea vocal pongo bandera en falso" 
			bandera:= false.
			]. 
		].
	(bandera) ifTrue: [ 
		salida:= (salida, ultimaLetra asUppercase asString).
		].
	
	].

^salida.



"CLASE 24/10"

"Implementar un método que permita buscar en un arreglo numerico, el elemento mayor y el elemento menor. Se debe devolver un nuevo arreglo, con los datos encontrados: 
MenorValor y posición		Mayor valor y posición"
"Clase: Array"
buscarMenorMayor

| arreglo salida mayor posMayor menor posMenor |

arreglo:= self.

"controlo que todos los elementos sean numeros"
arreglo do: [ :c| 
	(c isNumber) ifFalse: [ 
		^'Error, el arreglo tiene elementos que no son numeros'
		].
	].

salida:= Array new: 4.
mayor:= (arreglo at: 1).
posMayor:= 1.
menor:= (arreglo at: 1).
posMenor:= 1.

"salteo la primer iteracion" 
2 to: (arreglo size) do: [ :i| 	 	
	((arreglo at: i) < menor) ifTrue: [  		
		
		menor:= arreglo at: i.
		posMenor:= i
		]
	"sino es el menor pregunto por el mayor"
	ifFalse: [ 
		((arreglo at: i) > mayor) ifTrue: [  			
			mayor:= arreglo at: i. 			
			posMayor:= i.
			].
		].
	
	].

salida at: 1 put: menor.
salida at: 2 put: posMenor.
salida at: 3 put: mayor.
salida at: 4 put: posMayor.

^salida.



"Dado el siguiente arreglo de entrada #(menorValor, posim, mayorValor, posiM) tiene que devolver #(#(mnorValor, posim) #(mayorValor, posiM))"
"corregir (algo no funciona)"
formateaArreglo
"Clase: Array"

| arreglo salida aux |

arreglo:= self.
salida:= Array new: 2. "los elementos van hacer arreglos"
aux:= Array new: 2. 

1 to: 2 do: [ :i| 
	aux at: i put: (arreglo at: i).
	].
salida at: 1 put: aux.

1 to: 2 do: [ :i| 
	aux at: i put: (arreglo at: (i + 2)).
	].
salida at: 2 put: aux.

^salida.
